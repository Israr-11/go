<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 8-9: Production API Project</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; background: #0d1117; color: #c9d1d9; line-height: 1.6; }
        h1 { color: #58a6ff; border-bottom: 2px solid #58a6ff; padding-bottom: 10px; }
        h2 { color: #79c0ff; margin-top: 30px; }
        pre { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 16px; overflow-x: auto; }
        code { font-family: 'Courier New', monospace; color: #79c0ff; }
        .mapping { background: #1c2128; border-left: 4px solid #f0883e; padding: 15px; margin: 15px 0; }
        .project { background: #1c2128; border-left: 4px solid #3fb950; padding: 15px; margin: 15px 0; }
        .note { background: #1c2128; border-left: 4px solid #d29922; padding: 15px; margin: 15px 0; }
    </style>
</head>
<body>
    <h1>Week 8-9: Production-Ready API Project</h1>
    
    <p><strong>Goal:</strong> Build a complete, production-ready REST API using all concepts learned.</p>

    <div class="project">
        <h2>Project: Task Management API</h2>
        
        <p><strong>Features:</strong></p>
        <ul>
            <li>User registration and JWT authentication</li>
            <li>CRUD operations for tasks</li>
            <li>PostgreSQL database</li>
            <li>Middleware (auth, logging, CORS)</li>
            <li>Context timeouts and error handling</li>
            <li>Structured logging</li>
            <li>Comprehensive tests</li>
            <li>Docker support</li>
        </ul>
    </div>

    <h2>1. Project Structure</h2>

    <pre><code>taskapi/
├── cmd/
│   └── api/
│       └── main.go           # Application entry point
├── internal/
│   ├── database/
│   │   └── database.go       # DB connection
│   ├── handlers/
│   │   ├── auth.go           # Auth handlers
│   │   ├── tasks.go          # Task handlers
│   │   └── handlers_test.go
│   ├── middleware/
│   │   ├── auth.go           # Auth middleware
│   │   └── logging.go        # Logging middleware
│   ├── models/
│   │   └── models.go         # Data models
│   └── repository/
│       ├── users.go          # User DB operations
│       └── tasks.go          # Task DB operations
├── migrations/
│   └── 001_init.sql          # Database migrations
├── go.mod
├── go.sum
├── Dockerfile
└── docker-compose.yml
</code></pre>

    <h2>2. Database Models (internal/models/models.go)</h2>

    <pre><code>package models

import "time"

type User struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    Password  string    `json:"-"` // Never send password in JSON
    CreatedAt time.Time `json:"created_at"`
}

type Task struct {
    ID          int       `json:"id"`
    UserID      int       `json:"user_id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Status      string    `json:"status"` // pending, in_progress, completed
    Priority    int       `json:"priority"`
    DueDate     *time.Time `json:"due_date,omitempty"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}
</code></pre>

    <h2>3. Database Connection (internal/database/database.go)</h2>

    <pre><code>package database

import (
    "database/sql"
    "fmt"
    "os"
    
    _ "github.com/lib/pq"
)

func NewConnection() (*sql.DB, error) {
    host := getEnv("DB_HOST", "localhost")
    port := getEnv("DB_PORT", "5432")
    user := getEnv("DB_USER", "gouser")
    password := getEnv("DB_PASSWORD", "gopass")
    dbname := getEnv("DB_NAME", "taskdb")
    
    connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
        host, port, user, password, dbname)
    
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    // Test connection
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    // Connection pool settings
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    
    return db, nil
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
</code></pre>

    <h2>4. User Repository (internal/repository/users.go)</h2>

    <pre><code>package repository

import (
    "context"
    "database/sql"
    "fmt"
    
    "taskapi/internal/models"
    "golang.org/x/crypto/bcrypt"
)

type UserRepository struct {
    DB *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{DB: db}
}

func (r *UserRepository) Create(ctx context.Context, user *models.User, password string) error {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), 10)
    if err != nil {
        return err
    }
    
    query := `
        INSERT INTO users (name, email, password)
        VALUES ($1, $2, $3)
        RETURNING id, created_at
    `
    
    err = r.DB.QueryRowContext(ctx, query, user.Name, user.Email, string(hash)).
        Scan(&user.ID, &user.CreatedAt)
    
    return err
}

func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) {
    query := `SELECT id, name, email, password, created_at FROM users WHERE email = $1`
    
    user := &models.User{}
    err := r.DB.QueryRowContext(ctx, query, email).
        Scan(&user.ID, &user.Name, &user.Email, &user.Password, &user.CreatedAt)
    
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("user not found")
    }
    return user, err
}

func (r *UserRepository) VerifyPassword(hashedPassword, password string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
</code></pre>

    <h2>5. Task Repository (internal/repository/tasks.go)</h2>

    <pre><code>package repository

import (
    "context"
    "database/sql"
    
    "taskapi/internal/models"
)

type TaskRepository struct {
    DB *sql.DB
}

func NewTaskRepository(db *sql.DB) *TaskRepository {
    return &TaskRepository{DB: db}
}

func (r *TaskRepository) Create(ctx context.Context, task *models.Task) error {
    query := `
        INSERT INTO tasks (user_id, title, description, status, priority, due_date)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, created_at, updated_at
    `
    
    return r.DB.QueryRowContext(ctx, query,
        task.UserID, task.Title, task.Description, task.Status, task.Priority, task.DueDate).
        Scan(&task.ID, &task.CreatedAt, &task.UpdatedAt)
}

func (r *TaskRepository) GetByUserID(ctx context.Context, userID int) ([]models.Task, error) {
    query := `
        SELECT id, user_id, title, description, status, priority, due_date, created_at, updated_at
        FROM tasks
        WHERE user_id = $1
        ORDER BY created_at DESC
    `
    
    rows, err := r.DB.QueryContext(ctx, query, userID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var tasks []models.Task
    for rows.Next() {
        var task models.Task
        err := rows.Scan(&task.ID, &task.UserID, &task.Title, &task.Description,
            &task.Status, &task.Priority, &task.DueDate, &task.CreatedAt, &task.UpdatedAt)
        if err != nil {
            return nil, err
        }
        tasks = append(tasks, task)
    }
    
    return tasks, rows.Err()
}

func (r *TaskRepository) Update(ctx context.Context, task *models.Task) error {
    query := `
        UPDATE tasks
        SET title = $1, description = $2, status = $3, priority = $4, due_date = $5, updated_at = NOW()
        WHERE id = $6 AND user_id = $7
        RETURNING updated_at
    `
    
    return r.DB.QueryRowContext(ctx, query,
        task.Title, task.Description, task.Status, task.Priority, task.DueDate, task.ID, task.UserID).
        Scan(&task.UpdatedAt)
}

func (r *TaskRepository) Delete(ctx context.Context, id, userID int) error {
    query := `DELETE FROM tasks WHERE id = $1 AND user_id = $2`
    
    result, err := r.DB.ExecContext(ctx, query, id, userID)
    if err != nil {
        return err
    }
    
    rows, _ := result.RowsAffected()
    if rows == 0 {
        return sql.ErrNoRows
    }
    
    return nil
}
</code></pre>

    <h2>6. Auth Handlers (internal/handlers/auth.go)</h2>

    <pre><code>package handlers

import (
    "encoding/json"
    "net/http"
    "time"
    
    "taskapi/internal/models"
    "taskapi/internal/repository"
    
    "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your-secret-key-change-in-production")

type AuthHandler struct {
    UserRepo *repository.UserRepository
}

func NewAuthHandler(userRepo *repository.UserRepository) *AuthHandler {
    return &AuthHandler{UserRepo: userRepo}
}

func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name     string `json:"name"`
        Email    string `json:"email"`
        Password string `json:"password"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "Invalid input", http.StatusBadRequest)
        return
    }
    
    user := &models.User{
        Name:  input.Name,
        Email: input.Email,
    }
    
    if err := h.UserRepo.Create(r.Context(), user, input.Password); err != nil {
        http.Error(w, "Failed to create user", http.StatusInternalServerError)
        return
    }
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Email    string `json:"email"`
        Password string `json:"password"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
        http.Error(w, "Invalid input", http.StatusBadRequest)
        return
    }
    
    user, err := h.UserRepo.GetByEmail(r.Context(), input.Email)
    if err != nil {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }
    
    if err := h.UserRepo.VerifyPassword(user.Password, input.Password); err != nil {
        http.Error(w, "Invalid credentials", http.StatusUnauthorized)
        return
    }
    
    // Generate JWT
    claims := jwt.MapClaims{
        "user_id": user.ID,
        "email":   user.Email,
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    if err != nil {
        http.Error(w, "Failed to generate token", http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(map[string]string{
        "token": tokenString,
    })
}
</code></pre>

    <h2>7. Main Application (cmd/api/main.go)</h2>

    <pre><code>package main

import (
    "context"
    "log"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "taskapi/internal/database"
    "taskapi/internal/handlers"
    "taskapi/internal/middleware"
    "taskapi/internal/repository"
    
    "github.com/go-chi/chi/v5"
)

func main() {
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    
    // Connect to database
    db, err := database.NewConnection()
    if err != nil {
        logger.Error("Failed to connect to database", "error", err)
        os.Exit(1)
    }
    defer db.Close()
    
    // Initialize repositories
    userRepo := repository.NewUserRepository(db)
    taskRepo := repository.NewTaskRepository(db)
    
    // Initialize handlers
    authHandler := handlers.NewAuthHandler(userRepo)
    taskHandler := handlers.NewTaskHandler(taskRepo)
    
    // Setup router
    r := chi.NewRouter()
    
    // Global middleware
    r.Use(middleware.Logger(logger))
    r.Use(middleware.CORS)
    
    // Public routes
    r.Post("/auth/register", authHandler.Register)
    r.Post("/auth/login", authHandler.Login)
    
    // Protected routes
    r.Group(func(r chi.Router) {
        r.Use(middleware.Auth)
        r.Get("/tasks", taskHandler.List)
        r.Post("/tasks", taskHandler.Create)
        r.Put("/tasks/{id}", taskHandler.Update)
        r.Delete("/tasks/{id}", taskHandler.Delete)
    })
    
    // Start server
    server := &http.Server{
        Addr:    ":8080",
        Handler: r,
    }
    
    // Graceful shutdown
    go func() {
        logger.Info("Server starting", "port", 8080)
        if err := server.ListenAndServe(); err != http.ErrServerClosed {
            logger.Error("Server error", "error", err)
        }
    }()
    
    // Wait for interrupt
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    logger.Info("Shutting down server...")
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        logger.Error("Server shutdown error", "error", err)
    }
    
    logger.Info("Server stopped")
}
</code></pre>

    <h2>8. Database Migrations (migrations/001_init.sql)</h2>

    <pre><code>CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS tasks (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'pending',
    priority INT DEFAULT 1,
    due_date TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(status);
</code></pre>

    <h2>9. Docker Setup</h2>

    <p><strong>Dockerfile:</strong></p>
    <pre><code># Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o taskapi ./cmd/api

# Runtime stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/
COPY --from=builder /app/taskapi .

EXPOSE 8080

CMD ["./taskapi"]
</code></pre>

    <p><strong>docker-compose.yml:</strong></p>
    <pre><code>version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: gouser
      POSTGRES_PASSWORD: gopass
      POSTGRES_DB: taskdb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d

  api:
    build: .
    ports:
      - "8080:8080"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: gouser
      DB_PASSWORD: gopass
      DB_NAME: taskdb
    depends_on:
      - postgres

volumes:
  postgres_data:
</code></pre>

    <h2>10. Testing the API</h2>

    <pre><code># Start services
docker-compose up

# Register user
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{"name":"Alice","email":"alice@example.com","password":"password123"}'

# Login
TOKEN=$(curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","password":"password123"}' \
  | jq -r '.token')

# Create task
curl -X POST http://localhost:8080/tasks \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Go","description":"Complete roadmap","status":"in_progress","priority":1}'

# List tasks
curl http://localhost:8080/tasks \
  -H "Authorization: Bearer $TOKEN"
</code></pre>

    <h2>Key Takeaways</h2>
    <ul>
        <li>Organize code by feature (handlers, repositories, middleware)</li>
        <li>Use repository pattern for database operations</li>
        <li>Separate concerns (models, handlers, business logic)</li>
        <li>Use environment variables for configuration</li>
        <li>Implement graceful shutdown</li>
        <li>Docker for containerization</li>
        <li>Use migration files for database schema</li>
    </ul>

    <div class="note">
        <strong>Next Week:</strong> Performance profiling and optimization!
    </div>
</body>
</html>
