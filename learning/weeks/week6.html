<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 6: Concurrency - Goroutines & Channels</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; background: #0d1117; color: #c9d1d9; line-height: 1.6; }
        h1 { color: #58a6ff; border-bottom: 2px solid #58a6ff; padding-bottom: 10px; }
        h2 { color: #79c0ff; margin-top: 30px; }
        pre { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 16px; overflow-x: auto; }
        code { font-family: 'Courier New', monospace; color: #79c0ff; }
        .mapping { background: #1c2128; border-left: 4px solid #f0883e; padding: 15px; margin: 15px 0; }
        .project { background: #1c2128; border-left: 4px solid #3fb950; padding: 15px; margin: 15px 0; }
        .note { background: #1c2128; border-left: 4px solid #d29922; padding: 15px; margin: 15px 0; }
    </style>
</head>
<body>
    <h1>Week 6: Concurrency - Goroutines & Channels</h1>
    
    <p><strong>Goal:</strong> Master Go's concurrency primitives: goroutines, channels, and common patterns.</p>

    <h2>1. Goroutines Basics</h2>

    <div class="mapping">
        <strong>Python:</strong> <code>threading.Thread(target=func).start()</code> or <code>asyncio.create_task()</code><br>
        <strong>Go:</strong> <code>go func()</code> - lightweight, managed by Go runtime
    </div>

    <pre><code>package main

import (
    "fmt"
    "time"
)

func sayHello(name string) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Hello, %s! (%d)\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // Start goroutine
    go sayHello("Alice")
    go sayHello("Bob")
    
    // Main goroutine continues
    fmt.Println("Main function")
    
    // Wait for goroutines to finish
    time.Sleep(1 * time.Second)
    fmt.Println("Done")
}
</code></pre>

    <p><strong>Important:</strong> If main() exits, all goroutines are killed immediately!</p>

    <h2>2. WaitGroups for Synchronization</h2>

    <div class="mapping">
        <strong>Python:</strong> <code>thread.join()</code><br>
        <strong>Go:</strong> <code>sync.WaitGroup</code>
    </div>

    <pre><code>package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // Signal completion when function returns
    
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // Launch 5 workers
    for i := 1; i <= 5; i++ {
        wg.Add(1)  // Increment counter
        go worker(i, &wg)
    }
    
    // Wait for all workers to complete
    wg.Wait()
    fmt.Println("All workers completed")
}
</code></pre>

    <h2>3. Channels - Communication Between Goroutines</h2>

    <div class="mapping">
        <strong>Python:</strong> <code>queue.Queue()</code><br>
        <strong>Go:</strong> <code>chan</code> - built into the language
    </div>

    <pre><code>package main

import "fmt"

func main() {
    // Create a channel
    messages := make(chan string)
    
    // Send in goroutine
    go func() {
        messages <- "Hello"  // Send to channel
        messages <- "World"
    }()
    
    // Receive
    msg1 := <-messages  // Receive from channel
    msg2 := <-messages
    
    fmt.Println(msg1, msg2)
}
</code></pre>

    <h2>4. Buffered Channels</h2>

    <pre><code>package main

import "fmt"

func main() {
    // Unbuffered channel (blocks immediately)
    ch1 := make(chan int)
    
    // Buffered channel (can hold 3 items before blocking)
    ch2 := make(chan int, 3)
    
    // Can send 3 items without blocking
    ch2 <- 1
    ch2 <- 2
    ch2 <- 3
    
    // Receive
    fmt.Println(<-ch2)
    fmt.Println(<-ch2)
    fmt.Println(<-ch2)
}
</code></pre>

    <h2>5. Channel Iteration and Closing</h2>

    <pre><code>package main

import "fmt"

func producer(ch chan int) {
    for i := 1; i <= 5; i++ {
        ch <- i
    }
    close(ch)  // Signal no more values
}

func main() {
    ch := make(chan int)
    
    go producer(ch)
    
    // Receive until channel is closed
    for num := range ch {
        fmt.Println("Received:", num)
    }
    
    fmt.Println("Channel closed, done")
}
</code></pre>

    <h2>6. Select Statement (Multiplexing)</h2>

    <div class="mapping">
        <strong>Python:</strong> <code>asyncio.wait()</code> or polling<br>
        <strong>Go:</strong> <code>select</code> - wait on multiple channels
    </div>

    <pre><code>package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from channel 1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from channel 2"
    }()
    
    // Wait on multiple channels
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println(msg1)
        case msg2 := <-ch2:
            fmt.Println(msg2)
        }
    }
}
</code></pre>

    <h2>7. Worker Pool Pattern</h2>

    <pre><code>package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job)
        time.Sleep(time.Second)  // Simulate work
        results <- job * 2
    }
}

func main() {
    const numWorkers = 3
    const numJobs = 10
    
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    
    var wg sync.WaitGroup
    
    // Start workers
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, jobs, results, &wg)
    }
    
    // Send jobs
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Wait for workers to finish
    wg.Wait()
    close(results)
    
    // Collect results
    for result := range results {
        fmt.Println("Result:", result)
    }
}
</code></pre>

    <h2>8. Context for Cancellation</h2>

    <pre><code>package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d stopping: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    
    // Start workers
    for i := 1; i <= 3; i++ {
        go worker(ctx, i)
    }
    
    // Let them work for 2 seconds
    time.Sleep(2 * time.Second)
    
    // Cancel all workers
    fmt.Println("Cancelling workers...")
    cancel()
    
    // Give time to cleanup
    time.Sleep(1 * time.Second)
}
</code></pre>

    <h2>9. Mutex for Shared State</h2>

    <div class="mapping">
        <strong>Python:</strong> <code>threading.Lock()</code><br>
        <strong>Go:</strong> <code>sync.Mutex</code> or <code>sync.RWMutex</code>
    </div>

    <pre><code>package main

import (
    "fmt"
    "sync"
)

type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

func main() {
    counter := &SafeCounter{}
    var wg sync.WaitGroup
    
    // 1000 goroutines incrementing
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Println("Final count:", counter.Value())  // Will be 1000
}
</code></pre>

    <h2>10. Real-World Example: Concurrent API Fetcher</h2>

    <pre><code>package main

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "sync"
    "time"
)

type Result struct {
    URL  string
    Data map[string]interface{}
    Err  error
}

func fetchURL(ctx context.Context, url string, results chan<- Result) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        results <- Result{URL: url, Err: err}
        return
    }
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        results <- Result{URL: url, Err: err}
        return
    }
    defer resp.Body.Close()
    
    var data map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
        results <- Result{URL: url, Err: err}
        return
    }
    
    results <- Result{URL: url, Data: data}
}

func main() {
    urls := []string{
        "https://jsonplaceholder.typicode.com/posts/1",
        "https://jsonplaceholder.typicode.com/posts/2",
        "https://jsonplaceholder.typicode.com/posts/3",
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    results := make(chan Result, len(urls))
    var wg sync.WaitGroup
    
    // Fetch all URLs concurrently
    for _, url := range urls {
        wg.Add(1)
        go func(u string) {
            defer wg.Done()
            fetchURL(ctx, u, results)
        }(url)
    }
    
    // Close results channel when all fetches complete
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Collect results
    for result := range results {
        if result.Err != nil {
            fmt.Printf("Error fetching %s: %v\n", result.URL, result.Err)
        } else {
            fmt.Printf("Success: %s - %v\n", result.URL, result.Data["title"])
        }
    }
}
</code></pre>

    <div class="project">
        <h2>Weekend Mini-Project: Concurrent Image Processor</h2>
        
        <p><strong>Build a concurrent batch processor that:</strong></p>
        <ul>
            <li>Reads a list of URLs from a file</li>
            <li>Downloads them concurrently (max 5 workers)</li>
            <li>Processes each item (e.g., counts words in JSON response)</li>
            <li>Aggregates results</li>
            <li>Supports graceful cancellation (Ctrl+C)</li>
            <li>Adds rate limiting (max 10 requests/second)</li>
        </ul>

        <p><strong>Rate limiter example:</strong></p>
        <pre><code>package main

import (
    "fmt"
    "time"
)

func main() {
    // Rate limiter: 1 tick per 100ms (10/second)
    rateLimiter := time.Tick(100 * time.Millisecond)
    
    for i := 1; i <= 20; i++ {
        <-rateLimiter  // Wait for rate limit
        fmt.Printf("Request %d at %v\n", i, time.Now())
    }
}
</code></pre>

        <p><strong>Challenges:</strong></p>
        <ul>
            <li>Handle errors from workers gracefully</li>
            <li>Track progress (how many completed)</li>
            <li>Add timeout per request (5 seconds)</li>
            <li>Retry failed requests (max 3 attempts)</li>
        </ul>
    </div>

    <h2>Common Patterns Summary</h2>

    <pre><code>// Worker Pool
jobs := make(chan Job, 100)
results := make(chan Result, 100)

for i := 0; i < numWorkers; i++ {
    go worker(jobs, results)
}

// Fan-Out (distribute work)
for _, job := range jobs {
    jobsChan <- job
}

// Fan-In (collect results)
for i := 0; i < len(jobs); i++ {
    result := <-results
}

// Timeout
select {
case result := <-ch:
    // Got result
case <-time.After(5 * time.Second):
    // Timeout
}

// Cancellation
ctx, cancel := context.WithCancel(ctx)
defer cancel()

select {
case <-ctx.Done():
    return
default:
    // Continue working
}
</code></pre>

    <h2>Key Takeaways</h2>
    <ul>
        <li>Goroutines are cheap - can run thousands concurrently</li>
        <li>Use channels to communicate, not shared memory</li>
        <li>Always use <code>sync.WaitGroup</code> or channels to wait for completion</li>
        <li>Close channels when done producing (sender's responsibility)</li>
        <li><code>select</code> for multiplexing channels</li>
        <li>Use <code>context</code> for cancellation and timeouts</li>
        <li>Use <code>sync.Mutex</code> only when you must share memory</li>
        <li>Run with <code>go run -race</code> to detect data races</li>
    </ul>

    <div class="note">
        <strong>Next Week:</strong> Testing, benchmarking, and table-driven tests!
    </div>
</body>
</html>
