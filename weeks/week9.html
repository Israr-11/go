<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 9: Performance & Profiling</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; background: #0d1117; color: #c9d1d9; line-height: 1.6; }
        h1 { color: #58a6ff; border-bottom: 2px solid #58a6ff; padding-bottom: 10px; }
        h2 { color: #79c0ff; margin-top: 30px; }
        pre { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 16px; overflow-x: auto; }
        code { font-family: 'Courier New', monospace; color: #79c0ff; }
        .note { background:#1c2128; border-left: 4px solid #d29922; padding: 15px; margin: 15px 0; }
        .project { background: #1c2128; border-left: 4px solid #3fb950; padding: 15px; margin: 15px 0; }
    </style>
</head>
<body>
    <h1>Week 9: Performance & Profiling</h1>
    
    <p><strong>Goal:</strong> Learn to profile, optimize, and measure Go application performance.</p>

    <h2>1. CPU Profiling with pprof</h2>

    <pre><code>package main

import (
    "log"
    "net/http"
    _ "net/http/pprof"  // Import for side effects
)

func expensiveOperation() {
    // Some CPU-intensive task
    for i := 0; i < 1000000; i++ {
        _ = i * i
    }
}

func handler(w http.ResponseWriter, r *http.Request) {
    expensiveOperation()
    w.Write([]byte("Done"))
}

func main() {
    // pprof automatically registers handlers at:
    // /debug/pprof/
    
    http.HandleFunc("/api/work", handler)
    
    log.Println("Server on :8080, pprof on /debug/pprof")
    http.ListenAndServe(":8080", nil)
}
</code></pre>

    <p><strong>Generate CPUprofile:</strong></p>
    <pre><code># Generate load
hey -n 10000 -c 100 http://localhost:8080/api/work

# Capture 30-second CPU profile
curl http://localhost:8080/debug/pprof/profile?seconds=30 > cpu.prof

# Analyze with pprof
go tool pprof cpu.prof

# Commands in pprof:
(pprof) top       # Show top functions by CPU time
(pprof) list funcName  # Show source code
(pprof) web       # Open in browser (graphviz required)
</code></pre>

    <h2>2. Memory Profiling</h2>

    <pre><code>package main

import (
    "fmt"
    "runtime"
    "runtime/pprof"
    "os"
)

func allocateMemory() {
    // Allocate lots of slices
    data := make([][]byte, 0)
    for i := 0; i < 10000; i++ {
        data = append(data, make([]byte, 1024))
    }
}

func main() {
    // Create memory profile file
    f, _ := os.Create("mem.prof")
    defer f.Close()
    
    allocateMemory()
    
    // Write heap profile
    runtime.GC() // Get accurate stats
    pprof.WriteHeapProfile(f)
    
    fmt.Println("Memory profile written to mem.prof")
}

// Analyze:
// go tool pprof mem.prof
</code></pre>

    <p><strong>Live memory profiling:</strong></p>
    <pre><code># Capture heap profile
curl http://localhost:8080/debug/pprof/heap > heap.prof

# Analyze
go tool pprof heap.prof

# Check allocations
curl http://localhost:8080/debug/pprof/allocs > allocs.prof
go tool pprof allocs.prof
</code></pre>

    <h2>3. Optimization Example: String Concatenation</h2>

    <pre><code>package main

import (
    "fmt"
    "strings"
    "testing"
)

// Bad: Creates new string on each iteration
func concatWithPlus(strs []string) string {
    result := ""
    for _, s := range strs {
        result += s  // Allocates new string each time!
    }
    return result
}

// Good: Pre-allocates buffer
func concatWithBuilder(strs []string) string {
    var builder strings.Builder
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

// Better: Pre-size the builder
func concatWithBuilderCap(strs []string) string {
    var builder strings.Builder
    
    // Calculate total size
    totalSize := 0
    for _, s := range strs {
        totalSize += len(s)
    }
    builder.Grow(totalSize)
    
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

func BenchmarkConcatPlus(b *testing.B) {
    strs := []string{"hello", " ", "world", " ", "from", " ", "Go"}
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        concatWithPlus(strs)
    }
}

func BenchmarkConcatBuilder(b *testing.B) {
    strs := []string{"hello", " ", "world", " ", "from", " ", "Go"}
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        concatWithBuilder(strs)
    }
}

func BenchmarkConcatBuilderCap(b *testing.B) {
    strs := []string{"hello", " ", "world", " ", "from", " ", "Go"}
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        concatWithBuilderCap(strs)
    }
}
</code></pre>

    <p><strong>Run benchmarks:</strong></p>
    <pre><code>$ go test -bench=. -benchmem

BenchmarkConcatPlus-8           500000      3420 ns/op    176 B/op    6 allocs/op
BenchmarkConcatBuilder-8       3000000       480 ns/op     64 B/op    3 allocs/op
BenchmarkConcatBuilderCap-8    5000000       340 ns/op     32 B/op    1 allocs/op
</code></pre>

    <h2>4. JSON Encoding Optimization</h2>

    <pre><code>package main

import (
    "encoding/json"
    "testing"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// Slower: Marshal creates intermediate []byte
func encodeWithMarshal(user User) ([]byte, error) {
    return json.Marshal(user)
}

// Faster: Encoder writes directly
func encodeWithEncoder(user User) ([]byte, error) {
    var buf bytes.Buffer
    err := json.NewEncoder(&buf).Encode(user)
    return buf.Bytes(), err
}

func BenchmarkMarshal(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        json.Marshal(user)
    }
}

func BenchmarkEncoder(b *testing.B) {
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        var buf bytes.Buffer
        json.NewEncoder(&buf).Encode(user)
    }
}
</code></pre>

    <h2>5. Database Query Optimization</h2>

    <pre><code>package main

import (
    "context"
    "database/sql"
    "fmt"
)

// Bad: N+1 query problem
func getUsersWithTasksBad(db *sql.DB) error {
    users, _ := db.Query("SELECT id, name FROM users")
    defer users.Close()
    
    for users.Next() {
        var id int
        var name string
        users.Scan(&id, &name)
        
        // Separate query for each user!
        tasks, _ := db.Query("SELECT title FROM tasks WHERE user_id = $1", id)
        // ... process tasks
        tasks.Close()
    }
    return nil
}

// Good: Single query with JOIN
func getUsersWithTasksGood(db *sql.DB) error {
    query := `
        SELECT u.id, u.name, t.id, t.title
        FROM users u
        LEFT JOIN tasks t ON u.id = t.user_id
        ORDER BY u.id
    `
    
    rows, _ := db.Query(query)
    defer rows.Close()
    
    // Process joined results
    for rows.Next() {
        var userID int
        var userName string
        var taskID sql.NullInt64
        var taskTitle sql.NullString
        
        rows.Scan(&userID, &userName, &taskID, &taskTitle)
        // ... aggregate results
    }
    return nil
}
</code></pre>

    <h2>6. Caching with sync.Map</h2>

    <pre><code>package main

import (
    "sync"
    "time"
)

type Cache struct {
    data sync.Map
}

type CacheItem struct {
    Value      interface{}
    Expiration time.Time
}

func (c *Cache) Set(key string, value interface{}, duration time.Duration) {
    item := CacheItem{
        Value:      value,
        Expiration: time.Now().Add(duration),
    }
    c.data.Store(key, item)
}

func (c *Cache) Get(key string) (interface{}, bool) {
    val, ok := c.data.Load(key)
    if !ok {
        return nil, false
    }
    
    item := val.(CacheItem)
    
    // Check expiration
    if time.Now().After(item.Expiration) {
        c.data.Delete(key)
        return nil, false
    }
    
    return item.Value, true
}

// Usage in API handler
var userCache = &Cache{}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    userID := chi.URLParam(r, "id")
    
    // Try cache first
    if cached, ok := userCache.Get(userID); ok {
        json.NewEncoder(w).Encode(cached)
        return
    }
    
    // Fetch from DB
    user, err := fetchUserFromDB(userID)
    if err != nil {
        http.Error(w, "Not found", 404)
        return
    }
    
    // Cache for 5 minutes
    userCache.Set(userID, user, 5*time.Minute)
    
    json.NewEncoder(w).Encode(user)
}
</code></pre>

    <h2>7. Connection Pooling Best Practices</h2>

    <pre><code>package main

import (
    "database/sql"
    "time"
)

func setupDatabase() (*sql.DB, error) {
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }
    
    // Maximum open connections (active + idle)
    db.SetMaxOpenConns(25)
    
    // Maximum idle connections in pool
    db.SetMaxIdleConns(5)
    
    // Maximum lifetime of a connection
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // Maximum idle time before connection is closed
    db.SetConnMaxIdleTime(1 * time.Minute)
    
    return db, nil
}
</code></pre>

    <h2>8. Load Testing with hey</h2>

    <pre><code># Install hey
go install github.com/rakyll/hey@latest

# Basic load test
hey -n 10000 -c 100 http://localhost:8080/api/tasks

# With authorization
hey -n 10000 -c 100 \
    -H "Authorization: Bearer YOUR_TOKEN" \
    http://localhost:8080/api/tasks

# POST requests
hey -n 1000 -c 50 \
    -m POST \
    -H "Content-Type: application/json" \
    -d '{"title":"Test"}' \
    http://localhost:8080/api/tasks
</code></pre>

    <h2>9. Benchmark Comparison Tool</h2>

    <pre><code># Install benchstat
go install golang.org/x/perf/cmd/benchstat@latest

# Run benchmark multiple times
go test -bench=. -count=10 > old.txt

# Make optimizations, then run again
go test -bench=. -count=10 > new.txt

# Compare results
benchstat old.txt new.txt

# Output shows statistical significance:
# name        old time/op  new time/op  delta
# ConcatPlus  3.42µs ± 2%  3.45µs ± 1%   ~     
# ConcatBuilder  480ns ± 3%   340ns ± 2%  -29.17%
</code></pre>

    <div class="project">
        <h2>Weekend Project: Optimize Your API</h2>
        
        <p><strong>Tasks:</strong></p>
        <ul>
            <li>Add pprof endpoints to your API</li>
            <li>Load test with hey (1000 req/s target)</li>
            <li>Profile CPU and memory usage</li>
            <li>Identify and optimize bottlenecks</li>
            <li>Add caching for frequently accessed data</li>
            <li>Optimize database queries (add indexes, use EXPLAIN)</li>
            <li>Benchmark before/after optimizations</li>
        </ul>

        <p><strong>Metrics to track:</strong></p>
        <ul>
            <li>Requests per second (throughput)</li>
            <li>p50, p95, p99 latency</li>
            <li>Memory allocations per request</li>
            <li>Database query time</li>
        </ul>
    </div>

    <h2>Common Performance Tips</h2>
    <ul>
        <li>Use <code>strings.Builder</code> for string concatenation</li>
        <li>Pre-allocate slices when size is known: <code>make([]T, 0, size)</code></li>
        <li>Use <code>sync.Pool</code> for frequently allocated objects</li>
        <li>Avoid unnecessary JSON marshal/unmarshal</li>
        <li>Use buffered channels for better throughput</li>
        <li>Add database indexes on frequently queried columns</li>
        <li>Use prepared statements for repeated queries</li>
        <li>Implement caching for expensive operations</li>
        <li>Profile before optimizing (don't guess!)</li>
    </ul>

    <div class="note">
        <strong>Next Week:</strong> Deployment, Docker, and production readiness!
    </div>
</body>
</html>
